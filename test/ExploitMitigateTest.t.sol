// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "forge-std/Test.sol";
import "../src/unlimited-token-approval-mitigate.sol";

contract ExploitMitigateTest is Test {
    GalacticTokenMitigate tokenContract;
    address deployer = vm.addr(1);
    address victim = vm.addr(2);
    address attacker = vm.addr(3);

    function setUp() public {
        vm.prank(deployer);
        tokenContract = new GalacticTokenMitigate();

        // Initial setup
        vm.warp(block.timestamp + 1 hours);
        vm.prank(deployer);
        tokenContract.mint(5000);

        // Give victim some tokens
        vm.prank(deployer);
        tokenContract.transfer(victim, 1000);
    }

    function testMitigatedExploit() public {
        console.log("=== Mitigation Test Start ===");
        console.log("Victim initial balance:", tokenContract.balanceOf(victim));
        console.log(
            "Attacker initial balance:",
            tokenContract.balanceOf(attacker)
        );

        // Step 1: Victim attempts to approve attacker for an unlimited amount
        console.log(
            "Step 1: Victim attempts to approve attacker for type(uint256).max"
        );
        vm.prank(victim);
        vm.expectRevert(bytes("Approval exceeds balance"));
        tokenContract.approve(attacker, type(uint256).max);

        // Step 2: Victim approves attacker for a valid amount (e.g., 1000)
        uint256 approvedAmount = 1000;
        console.log(
            "Step 2: Victim approves attacker for",
            approvedAmount,
            "tokens"
        );
        vm.prank(victim);
        bool approveSuccess = tokenContract.approve(attacker, approvedAmount);
        assertTrue(approveSuccess, "Approval should succeed for valid amount");
        console.log("Approval successful");

        // Step 3: Attacker transfers approved amount from victim to themselves
        console.log(
            "Step 3: Attacker transfers",
            approvedAmount,
            "tokens from victim to themselves"
        );
        vm.prank(attacker);
        bool transferSuccess = tokenContract.transferFrom(
            victim,
            attacker,
            approvedAmount
        );
        assertTrue(
            transferSuccess,
            "TransferFrom should succeed for approved amount"
        );
        console.log("Transfer successful");

        console.log(
            "Victim balance after first transfer:",
            tokenContract.balanceOf(victim)
        );
        console.log(
            "Attacker balance after first transfer:",
            tokenContract.balanceOf(attacker)
        );

        // Step 4: Victim mints additional tokens
        uint256 mintedAmount = 2000;
        console.log("Step 4: Victim mints", mintedAmount, "additional tokens");
        vm.warp(block.timestamp + 1 hours);
        vm.prank(victim);
        tokenContract.mint(mintedAmount);
        console.log(
            "Victim balance after mint:",
            tokenContract.balanceOf(victim())
        );

        // Step 5: Attacker attempts to transfer more tokens than approved
        uint256 additionalTransfer = 2000;
        console.log(
            "Step 5: Attacker attempts to transfer",
            additionalTransfer,
            "additional tokens from victim"
        );
        vm.prank(attacker);
        vm.expectRevert(bytes("Insufficient allowance"));
        tokenContract.transferFrom(victim, attacker, additionalTransfer);

        console.log("Attempt to transfer additional tokens failed as expected");

        // Verify final balances
        console.log("Final Victim balance:", tokenContract.balanceOf(victim));
        console.log(
            "Final Attacker balance:",
            tokenContract.balanceOf(attacker)
        );

        // Assertions to ensure mitigation is effective
        assertEq(
            tokenContract.balanceOf(victim),
            1000 + mintedAmount - approvedAmount,
            "Victim balance should reflect minted tokens minus transferred amount"
        );
        assertEq(
            tokenContract.balanceOf(attacker),
            approvedAmount,
            "Attacker should only have the approved amount"
        );

        console.log("=== Mitigation Test Passed ===");
    }

    // Helper function to handle potential dynamic type returns
    function victimBalance() internal view returns (uint) {
        return tokenContract.balanceOf(victim);
    }
}
